<template>
  <div v-if="isMobile()" class="w-full">
    <MobileToolbar class="bg-gray-800 text-white">
      <template #start>
        <slot name="start" :menu="menu">
          <ButtonText class="text-xl" @click="callClose"
            ><i class="pi pi-times"></i
          ></ButtonText>
        </slot>
      </template>
      <template #center>
        <slot name="center" :menu="menu">
          <TextTitle class="text-white line-clamp-2">{{ title }}</TextTitle>
        </slot>
      </template>
      <template #end>
        <slot name="end" :menu="menu">
          <div class="flex flex-row w-full">
            <ButtonText
              class="text-xl"
              @click="emitEvent(menus[0], $event)"
              v-if="isShow"
              v-tooltip="menus[0].label"
            >
              <i :class="menus[0].icon"></i>
            </ButtonText>

            <ButtonText class="text-xl" @click="toggleMenu" v-if="isShow">
              <i class="pi pi-ellipsis-v"></i>
            </ButtonText>
          </div>
        </slot>
        <ContextMenu ref="menu" :model="menus as MenuItem[]" />
      </template>
    </MobileToolbar>
    <ConfirmDialog></ConfirmDialog>
  </div>
  <div v-else class="simpleapp-tool-bar">
    <Toolbar>
      <template #start>
        <div v-for="(menu, index) in menus" :key="index">
          <div v-if="menu.label && menu.type == 'crud'">
            <ButtonAction
              @click="emitEvent(menu, $event)"
              :action-name="menu.action"
              >{{ menu.label }}</ButtonAction
            >
          </div>
        </div>
      </template>
      <template #center>
        <TextTitle class="text-white line-clamp-2">{{ title }}</TextTitle>
      </template>
      <template #end>
        <div v-for="(menu, index) in menus" :key="index">
          <div v-if="menu.label && menu.type == 'docstatus'">
            <ButtonAction
              @click="emitEvent(menu, $event)"
              :action-name="menu.action"
              >{{ menu.label }}</ButtonAction
            >
          </div>
        </div>
      </template>
    </Toolbar>
    <ConfirmPopup></ConfirmPopup>
  </div>
  <Dialog v-model:visible="visiblePrintFormats" :header="t('printFormats')">
    <div>
      <ListView
        :list="printformats"
        #default="{ item, index }"
        @click="printPdf"
      >
        <div class="flex flex-col">
          <TextBold>{{ item.formatName }}</TextBold>
          <TextSubtitle>{{ item.description }}</TextSubtitle>
        </div>
      </ListView>
    </div>
  </Dialog>
  <Sidebar
    v-model:visible="visiblePrintPreview"
    :header="t('printPreview')"
    position="bottom"
  >
    <TextDanger v-if="printservererror || !printstr">
      {{ t("printServerError") }}
    </TextDanger>
    <vue-pdf-embed
      class="w-11/12"
      v-else-if="isMobile()"
      :source="printstr"
      :disableTextLayer="true"
    />
    <iframe v-else width="100%" height="100%" :src="printstr"></iframe>
  </Sidebar>
</template>
<script setup lang="ts">
/**
 * This file was automatically generated by simpleapp generator during initialization. It is changable.
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2024-04-02
 * author: Ks Tan
 */
import VuePdfEmbed from "vue-pdf-embed";

// import VuePdfKit from 'vue-pdf-kit'
// import 'vue-pdf-kit/dist/style.css'

import { SimpleAppClient } from "~/simpleapp/generate/clients/SimpleAppClient";
import { useConfirm } from "primevue/useconfirm";
import { FormActions, FormCrudEvent, FormMenu } from "~/types";
import { MenuItem } from "primevue/menuitem";
import { MenuItemCommandEvent } from "primevue/menuitem";
const confirm = useConfirm();
const emits = defineEmits(["on", "close"]);
const visiblePrintFormats = ref(false);
const visiblePrintPreview = ref(false);
const printstr = ref();
const printservererror = ref(false);
const props = defineProps<{
  document: SimpleAppClient<any, any>;
  disableaction?: string[];
}>();

const createData = async () => {
  try {
    return await doc.create();
  } catch (e) {
    console.debug("validation error:", e);
  }
};
const updateData = async () => {
  try {
    return await doc.update();
  } catch (e) {
    console.debug("validation error:", e);
  }
};
const deleteData = async () => {
  try {
    return await doc.delete();
  } catch (e) {
    console.debug("validation error:", e);
  }
};

const doc = props.document;
const data = doc.getReactiveData();
type Datatype = keyof typeof data.value;
const config = doc.getSchema()["x-simpleapp-config"];
const titlefield = (config.documentTitle ?? config.uniqueKey) as Datatype;
const title = computed(() =>
  data.value[titlefield as Datatype]
    ? data.value[titlefield as Datatype]
    : t(doc.getDocName()),
);
const printformats = doc.getSchema()["x-simpleapp-config"]?.printFormats;
const menu = ref();
const menus = computed(() =>
  [...getActions(), ...getDocActions()].filter((item) => showMenuButton(item)),
);

const isShow = computed(
  () => menus.value.filter((item) => item.action != undefined).length > 0,
);
const toggleMenu = (event: MouseEvent) => {
  menu.value.toggle(event);
};

const callClose = (e: MouseEvent) => {
  useNuxtApp().$event("CloseDialog", doc.getDocName());
  emitEvent({ action: "exit", type: "menu", label: "" }, e);
  // async (menu: FormMenu, clickEvent: MouseEvent)
};
const emitMobileEvent = (itemevent: MenuItemCommandEvent) => {
  const actionname: string = itemevent.item.action;
  const event = itemevent.originalEvent;
  // emitEvent({ action: actionname, type: "crud", label: "" }, event);
  emitEvent(itemevent.item, event);
};

const printPdf = async (index: number, format: any) => {
  printservererror.value = false;
  const formatid: string = format.formatId;
  visiblePrintPreview.value = true;
  // console.log("formatidformatid", format);
  try {
    const tmp: any = await doc
      .getApi()
      .runPrint(data.value._id ?? "", formatid);
    printstr.value = "data:application/pdf;base64," + tmp.data;
  } catch (e) {
    printservererror.value = true;
    printstr.value = "";
    console.error("error from print server", e);
  }
};
const getActions = () => {
  const actions = doc.getActions();
  const printformats = doc.getSchema()["x-simpleapp-config"]?.printFormats;
  const crudmenus: any[] = [];

  // Object.keys(actions).forEach((key)=>{ //crud, api, docstatus
  actions["crud"].forEach((item) => {
    if (props.disableaction && props.disableaction.includes(item)) {
      /*skip this item*/
    } else {
      crudmenus.push({
        action: item,
        label: t(item),
        type: "crud",
        icon: getActionIcon(item),
        command: emitMobileEvent,
      });
    }
  });
  if (printformats && printformats.length > 0) {
    crudmenus.push({
      action: "print",
      label: t("print"),
      type: "crud",
      icon: "pi pi-print",
      command: showPrintFormats,
    });
  }
  console.log("crudmenus", crudmenus);

  // })
  return crudmenus;
};

const showPrintFormats = () => {
  visiblePrintFormats.value = true;
  // console.log("showPrintFormatContext",itemEvent)
};
const emitEvent = async (menu: FormMenu, clickEvent: Event | MouseEvent) => {
  if (menu.action == "delete") {
    confirm.require({
      target: clickEvent.target as HTMLElement,
      header: t("deleteRecord"),
      message: `${t("deleteThisRecord?")}`,

      // icon: "pi pi-exclamation-triangle gap-4",
      acceptClass: "bg-danger-600 text-white",
      accept: async () => {
        if (await deleteData()) emits("on", FormCrudEvent.delete);
      },
    });
  } else {
    if (menu.action == "print") {
      showPrintFormats();
    } else if (menu.action == "create") {
      if (await createData()) emits("on", FormCrudEvent.create);
    } else if (menu.action == "update") {
      if (await updateData()) emits("on", FormCrudEvent.update);
    } else if (menu.type == "docstatus") {
      emits("on", FormCrudEvent.setDocStatus, menu.action);
    } else if (menu.action == FormCrudEvent.exit)
      emits("on", FormCrudEvent.exit);
  }
};

const getDocActions = () => {
  const docstatus: string = data.value.documentStatus;
  const allstatus = doc.getSchema()["x-simpleapp-config"].allStatus;
  let docactionmenus: FormMenu[] = [];
  type stringlist = { [key: string]: string };
  const statusNames: stringlist = {};
  allstatus?.forEach((item) => {
    statusNames[item.status] = t(item.statusName);
  });
  if (allstatus) {
    const stateconfig = allstatus.find((item) => item.status === docstatus);
    docactionmenus =
      stateconfig?.actions.map((item) => ({
        action: item,
        label: statusNames[item],
        type: "docstatus",
        icon: getActionIcon(item),
        command: emitMobileEvent,
      })) ?? [];
  }
  return docactionmenus;
};
const showMenuButton = (menu: FormMenu) => {
  if (menu.separator) return true;

  if (menu.action == "print") return true;
  //all document status cannot direct apply regardless new or draft
  if (menu.type == "docstatus") return true;

  // afterward, new document only acces create action
  if (doc.isNew() && menu.action == "create") return true;
  if (doc.isNew() && menu.action != "create") return false;

  //start from here, readonly document all action not allow
  if (doc.isReadOnly()) return false;

  //edit draft document, only create not allow
  if (!doc.isNew() && menu.action == "create") return false;
  if (!doc.isNew() && menu.action != "create") return true;

  return false;
};

const getActionIcon = (actionName: string) => {
  let icon = "";
  switch (actionName) {
    case "create":
      icon = "pi-save";
      break;
    case "update":
      icon = "pi-save";
      break;
    case "delete":
      icon = "pi-trash";
      break;
    case "confirm":
      icon = "pi-check";
      break;
    case "void":
      icon = "pi-ban";
      break;
    case "print":
      icon = "pi-print";
      break;
    case "draft":
      icon = "pi-pencil";
      break;
    default:
      icon = "pi-question-circle";
      break;
  }
  return `pi ${icon}`;
};
</script>
<style>
.vue-pdf-embed {
  @apply p-4;
}
.vue-pdf-embed > div {
  @apply mb-4;
  /* margin-bottom: 8px;
    box-shadow: 0 2px 8px 4px rgba(0, 0, 0, 0.1); */
}
</style>
