<template>
  <form class="simpleapp-form" @submit.prevent="true">
    <slot name="default" :data="document.getData()" :getField="getField"></slot>
  </form>
</template>
<script setup lang="ts">
/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2023-10-28
 * Author: Ks Tan
 */
import jsonpath from "jsonpath";
import { SimpleAppClient } from "~/simpleapp/generate/clients/SimpleAppClient";
import type { JSONSchema7, JSONSchema7Definition } from "json-schema";
import * as alldefaults from "~/simpleapp/generate/defaults";
import _, { upperFirst } from "lodash";
const props = defineProps<{
  
  document: SimpleAppClient<any, any>;
  readonly?: boolean;
}>();
if (!props.document) {
  throw "undefine SimpleAppForm property 'document'";
}

const isreadonly = computed(() =>
  props.readonly ? props.readonly : props.document.isReadOnly(),
);

// const obj = {schema:props.schema,data: props.schema}
const getField = (path: string) => {
  // console.log("simpleform topath",path)
  const data = props.document.getData();
  const schema = props.document.getSchema() as JSONSchema7; //force type for compatibility
  const fieldsetting = getPathObject(schema, path);
  // console.log("setting",fieldsetting)

  type defaulttype = typeof alldefaults;
  type keytype = keyof defaulttype;

  const x: keytype = ("Default" + props.document.getDocName(true)) as keytype;
  const defaultvalue = alldefaults[x](randomUUID());
  return {
    path: path,
    key: _.last(path.split("/")),
    instancepath: getInstancePath(schema, path),
    fieldsetting: fieldsetting,
    modelObject: data,
    document: props.document,
    apiObj: props.document.getApi(),
    modelField: "email",
    isrequired: getIsRequired(schema, path),
    errors: props.document.getErrors(),
    readonly: isreadonly.value,
    defaultValue: defaultvalue,
  }; //as SimpleAppFieldSetting
};

//    "schemaPath": "#/properties/email/format",

const getIsRequired = (schema: any, path: string) => {
  if (!path) {
    console.error("unknown path");
    return "xx";
  }

  try {
    let paths = path.replace("#/", "").split("/");
    const fieldname = paths[paths.length - 1];
    paths = paths.slice(0, -2);
    let tmp = schema;
    for (let i = 0; i < paths.length; i++) {
      tmp = tmp[paths[i]];
    }
    if (Array.isArray(tmp["required"])) {
      const arr: string[] = tmp["required"];
      return arr.includes(fieldname);
    } else {
      return false;
    }

    // console.log("get instance path",instancepath)

    // return tmp
  } catch (err: any) {
    console.error(err.message);
  }
};
const getInstancePath = (schema: any, path: string) => {
  if (!path) {
    console.error("unknown path");
    return "yy";
  }
  try {
    let paths = path.replace("#/", "").split("/");
    let tmp = schema;
    let instancepath = "";
    for (let i = 0; i < paths.length; i++) {
      tmp = tmp[paths[i]];
      if (tmp["type"] && paths[i] != "items") {
        instancepath = instancepath + "/" + paths[i];
      }
    }

    // console.log("get instance path",instancepath)
    return instancepath;
    // return tmp
  } catch (err: any) {
    console.error(err.message);
  }

  // let paths = path.replace('#/','').split('/')
  // return '/'+paths[1]
};
const getPathObject = (
  schema: JSONSchema7,
  path: string,
): JSONSchema7 | undefined => {
  // console.log("path",path)
  if (!path || !path.includes("#/properties")) {
    console.error("unknown path");
    return undefined;
  }
  try {
    const modifiedpath = path.replace("#", "$").replaceAll("/", ".");
    const queryresult = jsonpath.query(schema, modifiedpath)[0];
    return queryresult;
  } catch (err: any) {
    console.error(err.message);
  }
};
</script>
